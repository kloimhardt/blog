---
layout: post
title:  "draft hamilton"
date:   2023-03-21 06:00:01 +0100
categories: HamiltonMechanics
---
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
    <style>
     .CodeMirror { max-height: 150px; }
    </style>

    <script>
     window.klipse_settings = {
         selector_eval_js: '.language-klipse-eval-js',
         selector_eval_scheme: '.language-klipse-scheme, .language-eval-scheme',
         codemirror_options_in: {
             mode: 'scheme'
         }
     };
    </script>

    <script src="/blog/js/blog_helper.js"></script>
    <script>setKlipseUrl("https://storage.googleapis.com/app.klipse.tech/plugin_prod/js/klipse_plugin.min.js");</script>

</head>

<body onload = "loadKlipse();">
    <iframe id="book-part3" sandbox="allow-same-origin"
            src="/blog/html/sicmutils-as-js-book-part3.html"
            width="735" height="100">
    </iframe>

    <p></p>

    <script src="/blog/js/main.js"></script>
    <script src="/blog/js/compiler_config.js"></script>

    <pre id="klipse-scheme"></pre>
    <script>
     addSnippet('book-part3','klipse-scheme');
    </script>

    <pre id="compiler"></pre>
    <script>
     addSnippet('book-part3','compiler');
    </script>

    <pre id="prefix-123"></pre>
    <script>
     compiler_config_patchEvalOnce();
     addSnippet('book-part3','prefix-123');
    </script>

    <p> Let's define a frequency of seven cycles per second</p>

    <pre><code class="language-klipse-eval-js">
(define sec-ten (* 10 'sec)) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(define f (/ 7 'sec)) 
    </code></pre>

    <p>Just two functions q(t) and p(t). We measure q in meters and p in sparks.</p>

    <pre><code class="language-klipse-eval-js">
(define (q-cosine t) (* (cos (* f t)) 'meters)) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(define (p-atan t) (* (atan (* f t)) 'sparks)) 
    </code></pre>

    <p>The state is the combination of t, q, p into one entity, a three component vector</p>

    <pre id="qp->H-state-path"><code class="language-klipse-eval-js">
        <script>addSnippet('book-part3',"qp->H-state-path");</script>
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(define State-cosine-path (qp->H-state-path q-cosine p-atan)) 
    </code></pre>

    <p>State-cosine-path is a function</p>

    <pre><code class="language-klipse-eval-js">
(identity State-cosine-path) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(define time-point (* 10 'sec)) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(State-cosine-path time-point) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(define State-cosine-ten-seconds (State-cosine-path time-point)) 
    </code></pre>


    <pre><code class="language-klipse-eval-js">
(coordinate State-cosine-ten-seconds) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
loadEnv("momentum");
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(momentum State-cosine-ten-seconds) 
    </code></pre>

    <p>
        Our beloved harmonic oscillator: a ball of some weight on a spring of some strength.
    </p>

    <pre><code class="language-klipse-eval-js">
(define ((H-harmonic strength one_over_mass) state)
(let ((q (coordinate state))
(p (momentum state)))
(+ (/ (* strength (square q)) 2)
   (/ (* one_over_mass (square p)) 2)))) 
    </code></pre></body>

<p>
    Let's measure weight in feathers, and strength in groans. These are made up unities but hopefully vivid ones.
</p>

<pre><code class="language-klipse-eval-js">
(define H-pumping-feather (H-harmonic (* 5 'groans) (* 3 'feathers))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(H-pumping-feather State-cosine-ten-seconds) 
</code></pre>

<p>
A state is really just numbers. It is the state-path wich is a function of time.
</p>

<pre><code class="language-klipse-eval-js">
(define State-word-numbers (up 'zero 'one 'two)) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(identity State-word-numbers) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(H-pumping-feather State-word-numbers) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define State-numbers (up 0 1 2)) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(H-pumping-feather State-numbers) 
</code></pre>

<p>H-pumping-feather is a function that takes numbers</p>
<pre><code class="language-klipse-eval-js">
(identity H-pumping-feather) 
</code></pre>

<p>If we want to calculate the Hamiltonian at an arbitrary point in time, we need to do this</p>

<pre><code class="language-klipse-eval-js">
(define H-pumping-feather-arbitrary
  (compose H-pumping-feather State-cosine-path)) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(H-pumping-feather-arbitrary 't) 
</code></pre>

<pre id="Hamiltonian->state-derivative"><code class="language-klipse-eval-js">
    <script>addSnippet('book-part3',"Hamiltonian->state-derivative");</script>
</code></pre>

<pre><code class="language-klipse-eval-js">
((Hamiltonian->state-derivative H-pumping-feather)
  State-numbers) 
</code></pre>

<pre><code class="language-klipse-eval-js">
((Hamiltonian->state-derivative H-pumping-feather)
  State-word-numbers) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(identity State-cosine-ten-seconds) 
</code></pre>

<pre><code class="language-klipse-eval-js">
((Hamiltonian->state-derivative H-pumping-feather)
  State-cosine-ten-seconds) 
</code></pre>

<p>Same as above, if we want to calculate the Hamiltonian->state-derivative at an arbitrary point in time, we need to do this</p>

<pre><code class="language-klipse-eval-js">
((compose (Hamiltonian->state-derivative H-pumping-feather)
  State-cosine-path) 't) 
</code></pre>

<pre><code class="language-klipse-eval-js">
((D State-cosine-path) 't) 
</code></pre>

<pre id="Hamilton-equations"><code class="language-klipse-eval-js">
    <script>addSnippet('book-part3',"Hamilton-equations");</script>
</code></pre>

<pre><code class="language-klipse-eval-js">
(((Hamilton-equations H-pumping-feather) q-cosine p-atan) 't) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define (q-cos t) (* 'A (cos (* 'w t)))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define (p-sin t) (* 'B (sin (* 'w t)))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(((Hamilton-equations H-pumping-feather) q-cos p-sin) 't) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define w (sqrt (* 4 'groans 3 'feathers))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define (q-cosw t) (* 'A (cos (* w t)))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define B (/ (* 4 'groans 'A) w)) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define (p-sinw t) (* B (- (sin (* w t))))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(((Hamilton-equations H-pumping-feather) q-cosw p-sinw) 't) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define q (literal-function 'x)) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define p (literal-function 'p_x)) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(((Hamilton-equations H-pumping-feather) q p) 't) 
</code></pre>

</html>
