---
layout: post
title:  "draft hamilton"
date:   2023-03-21 06:00:01 +0100
categories: HamiltonMechanics
---
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
    <style>
     .CodeMirror { max-height: 150px; }
    </style>

    <script>
     window.klipse_settings = {
         selector_eval_js: '.language-klipse-eval-js',
         selector_eval_scheme: '.language-klipse-scheme, .language-eval-scheme',
         codemirror_options_in: {
             mode: 'scheme'
         }
     };
    </script>

    <script src="/blog/js/blog_helper.js"></script>
    <script>setKlipseUrl("https://storage.googleapis.com/app.klipse.tech/plugin_prod/js/klipse_plugin.min.js");</script>

</head>

<body onload = "loadKlipse();">
    <iframe id="book-part3" sandbox="allow-same-origin"
            src="/blog/html/sicmutils-as-js-book-part3.html"
            width="735" height="100">
    </iframe>

    <p></p>

    <script src="/blog/js/main.js"></script>
    <script src="/blog/js/compiler_config.js"></script>

    <pre id="klipse-scheme"></pre>
    <script>
     addSnippet('book-part3','klipse-scheme');
    </script>

    <pre id="compiler"></pre>
    <script>
     addSnippet('book-part3','compiler');
    </script>

    <pre id="prefix-123"></pre>
    <script>
     compiler_config_patchEvalOnce();
     addSnippet('book-part3','prefix-123');
    </script>

    <p>Any timestamp is measured in seconds. We define the specific timestamp of eight seconds.</p>

    <pre><code class="language-klipse-eval-js">
(define secTWO (* 2 'sec)) 
    </code></pre>

    <p>Any coordiante-point is measured in meters. We define a specific coordinate-point.</p>

    <pre><code class="language-klipse-eval-js">
(define mtrSEVEN (* 7 'meters)) 
    </code></pre>

    <p>Any momentum is measured in sparks. We define a specific momentum.</p>

    <pre><code class="language-klipse-eval-js">
(define spkFIVE (* 5 'sparks)) 
    </code></pre>

    <p>Any state is given as an up-tuple. We define a specific state<p>

        <pre><code class="language-klipse-eval-js">
(define upSVEN (up secTWO mtrSEVEN spkFIVE)) 
        </code></pre>

        <p>We can get the cooridnate out of a state</p>

        <pre><code class="language-klipse-eval-js">
(coordinate upSVEN) 
        </code></pre>

        <p>We can get the momentum out of a state</p>

        <pre><code class="language-klipse-eval-js">
(momentum upSVEN) 
        </code></pre>

        <p>Any stength of a spring is measured in groans. We define the specific spring with the strength of five groans.</p>

        <pre><code class="language-klipse-eval-js">
(define grnSPRING (* 4 'groans)) 
        </code></pre>

        <p>Any body's resistance to movement is measured in grams. We define a specific body with the resistance of three grams.</p>

        <pre><code class="language-klipse-eval-js">
(define ftrBALL (* 9 'grams)) 
        </code></pre>

        <p>Any energy is measured in calories. Any Hamiltonian is given as a function that takes some state and returns an energy. We define the specific Hamiltonian of our body of specific resistence attached to our spring of specific strength.</p>

        <pre><code class="language-klipse-eval-js">
(define (cal<-spring-ball upSTATE)
  (let ((q (coordinate upSTATE))
        (p (momentum upSTATE)))
    (+ (/ (* grnSPRING (square q)) 2)
       (/ (square p) (* ftrBALL 2))))) 
        </code></pre>

        <p>We apply the Hamiltonian to the state</p>

        <pre><code class="language-klipse-eval-js">
(cal<-spring-ball upSVEN) 
        </code></pre>

        <p>We realize that by defining our specific Hamiltonian, we also determined sparks in terms of feathers and calories</p>

        <pre><code class="language-klipse-eval-js">
(define sparks (sqrt (* 'calories 'grams))) 
        </code></pre>

        <pre><code class="language-klipse-eval-js">
(define upSEVEN (up secTWO mtrSEVEN (* 5 sparks))) 
        </code></pre>

        <p>We realize that by defining our specific Hamiltonian, we also determined groans in terms of meters and calories</p>

        <pre><code class="language-klipse-eval-js">
(define groans (/ 'calories (square 'meters))) 
        </code></pre>

        <pre><code class="language-klipse-eval-js">
(define (cal<-harmonic upSTATE)
  (let ((q (coordinate upSTATE))
        (p (momentum upSTATE)))
    (+ (/ (* (* 4 groans) (square q)) 2)
       (/ (square p) (* ftrBALL 2))))) 
        </code></pre>

        <pre><code class="language-klipse-eval-js">
(cal<-harmonic upSEVEN) 
        </code></pre>

        <p>Any frequency is measured in cycles.</p>

        <pre><code class="language-klipse-eval-js">
(define cycles (/ 1 'sec)) 
        </code></pre>

        <p>We define the specific frequency.</p>

        <pre><code class="language-klipse-eval-js">
(define cylTHREE (* 3 cycles)) 
        </code></pre>

    <p>We define a coordinate-function that takes some timestamp and returns a coordinate-point</p>

    <pre><code class="language-klipse-eval-js">
(define (mtr<-cosine secT)
  (* (cos (* cylTHREE secT)) 'meters)) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(mtr<-cosine secTWO) 
    </code></pre>

    <p>We define a momentum-function that takes some timestamp and returns a momentum.</p>

    <pre><code class="language-klipse-eval-js">
(define (spk<-atan secT) (* (atan (* cylTHREE secT)) sparks)) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(spk<-atan secTWO) 
    </code></pre>

    <p>We defina a higher order function called state-path. state-path takes some coordinate-function and some momentum-function. state-path returns a function that takes some timestamp and returns a state.</p>

    <pre><code class="language-klipse-eval-js">
(define ((state-path mtr<-q spk<-p) secT)
  (up secT (mtr<-q secT) (spk<-p secT))) 
    </code></pre>

    <p>The function that state-path returns is called a path-function. We define a specific path-function.</p>

    <pre><code class="language-klipse-eval-js">
(define up<-path-cosine (state-path mtr<-cosine spk<-atan)) 
    </code></pre>

    <p>We show that indeed, like any path-function, up<-path-cosine is a function that takes some timestamp and returns a state</p>

    <pre><code class="language-klipse-eval-js">
(identity up<-path-cosine) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(up<-path-cosine secTWO) 
    </code></pre>

    <p>We take the derivative of the state-path</p>

    <pre><code class="language-klipse-eval-js">
((D up<-path-cosine) secTWO) 
    </code></pre>

    <p>We define another specific state.</p>

    <pre><code class="language-klipse-eval-js">
(define upSIX (up<-path-cosine secTWO)) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(coordinate upSIX) 
    </code></pre>

    <p>We apply our Hamiltonian to this state</p>

    <pre><code class="language-klipse-eval-js">
(cal<-harmonic upSIX) 
    </code></pre>

    <p>Taking partial derivatives</p>

    <pre><code class="language-klipse-eval-js">
(((partial 1) cal<-harmonic) upSEVEN) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(((partial 2) cal<-harmonic) upSEVEN) 
    </code></pre>

    <p>The state-derivative is a higher order function. It takes some Hamiltonian and calculates the derivative of it. Using that, the state-derivative returns a function that takes some state and returns a path function.</p>

    <pre><code class="language-klipse-eval-js">
(define ((state-derivative cal<-Hamiltonian) upSTATE)
  (up 1
      (((partial 2) cal<-Hamiltonian) upSTATE)
      (- (((partial 1) cal<-Hamiltonian) upSTATE)))) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
(state-derivative cal<-harmonic) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
((state-derivative cal<-harmonic) upSEVEN) 
    </code></pre>


    <pre><code class="language-klipse-eval-js">
((state-derivative cal<-harmonic) upSIX) 
    </code></pre>

    <p>We show how to apply our Hamiltonian directly to the timestamp using  path-function as an intermediary between the two. The composition of a Hamiltonian with a path-function is a simple function of time, i.e. a function that takes a number of seconds and returns a number of calories.</p>

    <pre><code class="language-klipse-eval-js">
((compose cal<-harmonic up<-path-cosine) secTWO) 
    </code></pre>

<pre><code class="language-klipse-eval-js">
((compose (state-derivative cal<-harmonic)
   up<-path-cosine)
  secTWO) 
</code></pre>

<p>Hamilton-equations is a higher order function. It takes some Hamiltonian. It returns a function that takes some coordinate-function and some momentum-function and returns a path-function.</p>

<pre><code class="language-klipse-eval-js">
(define ((Hamilton-equations cal<-Hamiltonian) mtr<-q spk<-p)
  (let ((up<-path (state-path mtr<-q spk<-p)))
    (- (D up<-path)
       (compose (state-derivative cal<-Hamiltonian)
                up<-path)))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(((Hamilton-equations cal<-harmonic) mtr<-cosine spk<-atan) secTWO) 
</code></pre>

<p>
For realizable coordinate- and momentum-functions, the Hamilton-equantions path-function needs to be identically zero. By looking at the previous result, we realize that by defining the Hamilton equations, we also determined calories in terms of meters and seconds.
</p>

<pre><code class="language-klipse-eval-js">
(define calories (/ (* (square 'meters) 'grams) (square 'sec))) 
</code></pre>

<p>This implies new sparks and groans</p>

<pre><code class="language-klipse-eval-js">
(define new-sparks (sqrt (* calories 'grams))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define new-groans (/ calories (square 'meters))) 
</code></pre>

<p>We redefine the coordinate and momentum function</p>

<pre><code class="language-klipse-eval-js">
(define mb (* 'ma 'grams)) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define kb (* 'ka new-groans)) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define Eb (* 'En calories)) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define ww (sqrt (/ kb mb))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define mtrQNULL (sqrt (/ (* 2 Eb) (* mb (square ww))))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define spkPNULL (sqrt (* 2 mb Eb))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define (mtr<-q secT) (* mtrQNULL (sin (* ww secT)))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define (spk<-p secT) (* spkPNULL (cos (* ww secT)))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(define (cal<-hamiltonian upSTATE)
(let ((q (coordinate upSTATE))
      (p (momentum upSTATE)))
(+ (/ (* kb (square q)) 2)
   (/ (square p) (* mb 2))))) 
</code></pre>

<pre><code class="language-klipse-eval-js">
((compose cal<-hamiltonian (state-path mtr<-q spk<-p)) secTWO) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(((Hamilton-equations cal<-hamiltonian) mtr<-q spk<-p) secTWO) 
</code></pre>

<p>Unit checks</p>

<pre><code class="language-klipse-eval-js">
(/ mtrQNULL 'meters) 
</code></pre>

<pre><code class="language-klipse-eval-js">
(/ spkPNULL new-sparks) 
</code></pre>

<pre><code class="language-klipse-eval-js">
</code></pre>

</html>
