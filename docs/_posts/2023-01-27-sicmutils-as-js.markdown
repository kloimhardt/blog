---
layout: post
title:  "Sicmutils as JavaScript library"
date:   2023-01-27 00:00:01 +0100
categories: Software
---
In this blog post I argue that it is a good idea to use [Sicmutils](https://github.com/sicmutils/sicmutils) as a JavaScript library. If you do not know what Sicmutils is, most probably this text will not make any sense to you.

[Maria.cloud](https://www.maria.cloud) is a notebook platform, an ingenious one, but a platform, an online service. A Physicist, that is typically a male in his role at a university, does not like platforms. He shies away from uploading code and data to a cloud service.

The professional role of a physicist is to produce paper and pdf documents to be published in some paper journal. Motto: "this is my publication, this is the result of my research, I vouch for it with my reputation, it is meant to be read and criticised in exactly this form, certainly not to be changed and (god forbid) then republished under my name". The intermediate data processing is always done under time pressure, the code used never undergoes a code review, it is messy by its very nature. Certainly nothing to be published in the name of the university and research group.

Yes, I do know about all the discussions of "open science" and "open data" policies. But those can only be taken seriously as guiding ideas given the working circumstances of the average scientist. He is glad to get the next paper through peer review before being crushed in the mills of the system and perish.

This (at the moment) very rational and professional "keep code secret" attitude, I dare to claim, remains intact also in all the physicists semi-professional endeavours. Like, yes, trying out Sicmutils. In the back of his mind there is always the possibility that such doodles will be of use in funded research. Otherwise he would not try things out in the first place. My impression is that by habit all code is kept in small circles.

For a software developer this attitude is hard to understand. In his professional role he is used to be forced to publish buggy software. Only the most foolish of managers or customers expect his code to work properly. He happily uses Microsoft's Github online platform for open source work, it is there for everyone to mix and match. The one who blames him for bugs is shunned by the whole community ("do not criticise, send a bugfix"). Should the code eventually be used professionally, GitLab is installed on a private server, the code is migrated and off we go.

The physicist, even when ready to share semi-professional doodles, does not see (and in practice does indeed not have) this backdoor of migrating to a professional private platform. With every platform he ever started to learn, he also learned that he will be tied to this specific service forever. And even the most sanguine of scientists knows that keeping things secret can turn into a hard legal necessity for getting funds from private companies. Thus he decides for the thing everyone uses: Matlab with code stored locally on his laptop, shared by producing zip files sent via e-mail.

From what has been argued up to now, it follows that the physicist tends to trust books in paper form. After all, these are immutable publications open to merciless criticism by everyone and can therefore be given the benefit of the doubt. Because the book's author put on the line his reputation in the community. The very reason to keep code secret leads to trust in published paper.

And this is the great advantage of Sicmutils: it is based on the SICP and SICMechanics books. SICP is *the* standard textbook of computer science. A seminal work. As SICMechanics is by the same author, physicists will at least listen up when confronted with it. One only has to state the fact that it is the logical extension of the seminal SICP book. Both books exist as physical versions from MIT-press leading to increased trustability.

The problem with both books to reach a wider audience is the Scheme language. This language is not widely known. A physicist always looks for self-efficacy (hence the use of Matlab). "Why should I carry the mental load for learning Scheme?", he asks. "Because it is a simple language", is the answer. "Well yea, but I cannot use it anywhere else". A version of the "do not want to be tied to an unknown platform" argument again.

There is a reason why SICP now exists in a JavaScript version. Because learning JavaScript is perceived to increase self-efficacy. JavaScipt drives the Internet after all, al property Scheme does not share.

In any case, maybe some physicist can be convinced to buy and read SICMechanics despite its ample use of the Scheme language. After all, this book by a famous author solves the problem of arbitrariness of notation found in so many (if not all) physics textbooks. A situation which surely made him suffer more than one time in his life. Maybe he gets to share my belief that Classical Mechanics can nowhere else be understood so thoroughly and quick as with SICMechanics, once one has took the decision to learn Scheme in an afternoon.

Ok, now that the physicist is reading the SICMechanics book, he wants to enjoy the single most big benefit it offers: code some simple example on the computer to understand it better. Maybe derive the centripedal force by rotating an observer (an example which happened to open my eyes).

Looking for a possibility to hone his programming skills, he first of all concludes that installing MIT-scheme is out of the question. This is because he uses a Windows machine (it took me more than a day to get it up and running on my Windows laptop, I hated it). Fortunately, we have Sicmutils, it works online. On Maria.cloud.

As sure as a stone falls downward, the question will come up: "Is Maria-Cloud mandatory? Am I tied to it?". "No, No", the answer comes, "lots of people use Clojure locally on their windows laptops". An eyebrow is raised.

"Clojure? What has that to do with anything and what is that now". "Ah, do not worry, it is the same as Scheme except more modern, the syntax is almost the same". "Well", comes the answer "I agreed to learn Scheme, because it is used in this SICMechanics book by the author of a seminal book in computer science and now you tell me to use something slightly different. I want to do the exact same exercises as in the book I bought and trust, and you tell me I cannot do them as described?". "Well, with a bit of elbow grease, you know, all easy, there is Maria-Cloud and Github and Clojure and really cool ...".

I think one has to anticipate a conversation like the above before endorsing SICMechanics to someone. It needs lots of verbal arguments to justify investing ones time into Sicmutils in its Clojure form. And this is the reason why I think it is a good idea to use Sicmutils as a JavaScript library. The reason is that the use of JavaScipt does not need lots of verbal arguments. Html + JavaScript is the pure "show, don't tell" method of arguing the good cause of worldwide improvement of notation in programming and physics. Let me use lots of verbal arguments to tell you, the already converted Sicmutils disciple, why this is.

First of all one can show a simple demo of Sicmutils in a blog post by just using Html + JavaScript. The code will not look nice, but with a few JavaScript helper functions defined beforehand this can be mitigated at least a bit. With such a blog post, one has neutralised the "no tie to unknown stuff" argument. It is all Html and Javascript, technology which is amply demonstrated to run locally and offline without ceremony. The physicist does not feel tied in to something and his self-efficacy is catered for by JavaScript.

Agreed, by introducing JavaScript one is in this first step farther away from the SICMechanics book than when introducing Clojure, but Clojure is not there exactly either. My proposal to connect Sicmutils to the books is by building up a Scheme-to-JavaScript compiler along the way of going from one example to the next in a blog post. In this way SICMechanics is not only tied to Sicmutils but also to its famous predecessor SICP. Because SICP is all about building up a Scheme compiler.

Following this road, one has to learn basic JavaScript in order to understand SICMechanics. I think for people not willing to learn basic JS, my proposed road to do physics SICMechanics style is definitely blocked. But on the other hand, I personally know people who program spaghetti Matlab code and would like to know what real programming means. They do not know that no one knows how to program, but at least there is the functional method of the seminal SICP book. This combination of SICP+SICM can be whole heartedly recommended to anyone out there open to learn new things. Remember that SICP also exists in the JavaScript version, the version I would recommend for reference. We want to start with JavaScript after all and work our way up by building a compiler and physics examples both in parallel as needed.

In such a series of blog posts, I want to emphasise, the original SICMechanics book (= MIT-Scheme language) would become interactive for the first time. Think restoration of an old Chapel to its originally bright colours. It requires effort by the reader, but all he learns is timeless and universal (at least for an earthly human life span): Classical Mechanics and JavaScript in a most refined form. Maybe people then start to write their own blog posts, or at least send around HTML files by e-mail to be opened locally.

One could even imagine to present SICMechanics with a Matlab-to-JS compiler in a series of blog posts. This would be the holy grail of self-efficacy for a spaghetti Matlab coder who is curious to learn how to program. Instead of building up a Scheme compiler while working his way through the material, he builds up a compiler for the Matlab-syntax and then uses the already long-known familiar language to do the examples of SICMechanics.
