---
layout: post
title:  "Sicmutils as JavaScript library (2)"
date:   2023-02-21 06:00:01 +0100
categories: Software
---
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">

    <script>
     window.klipse_settings = {
         selector_eval_js: '.language-klipse-eval-js'
     };
    </script>
</head>

<body>
    <p>
        In this blog post I show you how to calculate rational numbers in JavaScript. I begin with a simple variable declaration
    </p>
    <pre><code class="language-klipse-eval-js">
var x = 1;
    </code></pre>
    <p>
    and a simple calculation
    </p>
    <pre><code class="language-klipse-eval-js">
x/2;
    </code></pre>
    <p>
        giving a floating point number. In case you are curious: I use <a href="https://blog.klipse.tech/javascript/2016/06/20/blog-javascript.html">Klipse</a> for code-execution, you can change all code and see the result immediately.
    </p>
    <p>
        Moving on, we note that we can always write any calculation as a function,
    </p>
    <pre><code class="language-klipse-eval-js">
var div = (x, y) => x/y;

div(x, 2);
    </code></pre>
    <p>
        and whereas the notation becomes clumsier, the result remains the same floating point number. But we can do better and get to rational numbers if we import the right JavaScript library.
    </p>
    <pre>&lt;script src=&quot;http://kloimwieder.com/sicmutils/demo/out/main.js&quot;&gt;&lt;/script&gt;</pre>

    <script src="http://kloimwieder.com/sicmutils/demo/out/main.js"></script>
    <p>
        This library was compiled according to the instructions found in the great <a href="https://github.com/sicmutils/sicmutils/tree/main/demo">Sicmutils</a> repository (changing compiler-options from :advanced to :simple).
    </p>
    <p>
        With the help of Sicmutils, we can redefine the calculation function
    </p>
    <pre><code class="language-klipse-eval-js">
var div = sicmutils.env._SLASH_;

div(x, 2).toString();
    </code></pre>
    <p>
        and get the result as a rational number. But how to get back to the usual notation using the <code>/</code> sign? For this we code the calculation as a string

    </p>
    <pre><code class="language-klipse-eval-js">
var formula = "[ x / 2 ]";
    </code></pre>
    <p>
        and first, within the string, replace the <code>/</code>
    </p>
    <pre><code class="language-klipse-eval-js">
var replaceMath = (txt) => txt.replace(/\//g,"div");

replaceMath(formula);
    </code></pre>
    <p>
        and second produce comma separated substrings. They do not look nice,
    </p>
    <pre><code class="language-klipse-eval-js">
var insertCommas = (txt) =>
txt.replace(/(\w+)/g,'"$1",')
   .replace(/\,\s\]/g," ]");

insertCommas(replaceMath(formula))
    </code></pre>
    <p>
        but allow us to easily convert the original string into a JavaScript array.
    </p>
    <pre><code class="language-klipse-eval-js">
var textToJson = (txt) =>
JSON.parse(insertCommas(replaceMath(txt)));

textToJson(formula);
    </code></pre>
    <p>
        This in turn allows for easy transformation into JavaScript code,
    </p>
    <pre><code class="language-klipse-eval-js">
// above: var formula = "[ x / 2 ]";

var jsonToJs = (j) =>
j[1] + "(" +  j[0] + ", " + j[2] + ")";

jsonToJs(textToJson(formula));
    </code></pre>
    <p>
        which is a string again. This JS-code string can be evaluated. First, we code the above learnings in a transformation function,
    </p>
    <pre><code class="language-klipse-eval-js">
var expressionToJs = (expr) =>
jsonToJs(textToJson(expr)) + ".toString();";

expressionToJs(formula);
    </code></pre>
    <p>
        and employ a small hack that kicks in our transpiler whenever code starts with a bracket -- square <code>[</code> or round <code>)</code>.
    </p>
    <pre>&lt;script&gt;
     var oldEval = window.eval;
     var newEval = (txt) =>
         txt[0] === "[" || txt[0] === "("
         ? oldEval(expressionToJs(txt))
         : oldEval(txt);
     window.eval = newEval;
&lt;/script&gt;</pre>

    <script>
     var oldEval = window.eval;
     var newEval = (txt) =>
         txt[0] === "[" || txt[0] === "("
         ? oldEval(expressionToJs(txt))
         : oldEval(txt);
     window.eval = newEval;
    </script>
    <p>
        Voil√†, our first rational calculation in JavaScript.
    </p>
    <pre><code class="language-klipse-eval-js">
[ x / 2 ]
    </code></pre>

    <p>
        Next we implement a more complicated formula,
    </p>
    <pre><code class="language-klipse-eval-js">
var formula = "((x / 2) / 2)";
    </code></pre>
    <p>
        which as a modification now uses round brackets <code>()</code>. Those have to be converted to square brackets.
    </p>
    <pre><code class="language-klipse-eval-js">
var makeBrackets = (txt) =>
txt.replace(/\(/g,"[ ")
.replace(/\)/g," ],")
.replace(/,$/,"");

var textToJson = (txt) =>
// old: JSON.parse(insertCommas(replaceMath(txt)))
JSON.parse(insertCommas(replaceMath(makeBrackets(txt))));

textToJson(formula)
    </code></pre>
    <p>
Since the formula is nested, we need a new function to transform a JS-array into JS-code.
    </p>
    <pre><code class="language-klipse-eval-js">
var jsonToJs = (j) =>
// old: j[1] + "(" +  j[0] + ", " + j[2] + ")"
j.constructor == Array
? jsonToJs(j[0]) + "(" +  j.slice(1).map(jsonToJs) + ")"
: j;

jsonToJs(textToJson(formula));
    </code></pre>
    <p>
        As you can see, we are not there yet, the symbols are somehow topsy-turvy, but we immediately notice that things work if we use prefix notation for our formula.
    </p>
    <pre><code class="language-klipse-eval-js">
jsonToJs(textToJson("(/ (/ x 2) 2)"));
    </code></pre>
    <p>
        This gives us a hint how the flaw can be fixed: we write a helper function that swaps all first two elements in a nested array,
    </p>

    <pre><code class="language-klipse-eval-js">
var swapFirst = (j) =>
j.constructor == Array
? [j[1], j[0]].concat(j.slice(2)).map(swapFirst)
: j;

swapFirst([["x", "div", 2], "div", 2]);
    </code></pre>
    <p>
        and add it to the transpiler function.
    </p>
    <pre><code class="language-klipse-eval-js">
var expressionToJs = (expr) =>
// old: jsonToJs(textToJson(expr)) + ".toString();";
jsonToJs(swapFirst(textToJson(expr))) + ".toString();";

expressionToJs(formula);
    </code></pre>

    <p>
        Finally, let's give our formula a try.
    </p>

    <pre><code class="language-klipse-eval-js">
((x / 2) / 2)
    </code></pre>


<script src="https://storage.googleapis.com/app.klipse.tech/plugin_prod/js/klipse_plugin.min.js"></script>
</body>
</html>
