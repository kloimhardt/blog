---
layout: post
title:  "Up and Compose"
date:   2023-03-20 06:00:01 +0100
categories: HamiltonMechanics
---
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">

    <script>
     window.klipse_settings = {
         selector_eval_js: '.language-klipse-eval-js'
     };
    </script>
</head>

<body>

    <h1>Arrays and Vectors in JavaScript</h1>

    <p>We include the Sicmutils library</p>

    <pre>&lt;script src=&quot;https://kloimhardt.github.io/blog/js/main.js&quot;&gt;&lt;/script&gt;</pre>

    <script src="https://kloimhardt.github.io/blog/js/main.js"></script>

    <p>Some abbreviations</p>

    <pre><code class="language-klipse-eval-js">
var up = sicmutils.env.up;
var cos = Math.cos;
var sin = Math.sin;
    </code></pre>
    <p>JavaScript arrays are a nice way to combine numbers and calculate.</p>

    <pre><code class="language-klipse-eval-js">
 [1, 0].map(sin);
    </code></pre>

    <p>In the same manner, the Sicmutils function <code>up</code> is a way to combine numbers to a vector.</p>

    <pre><code class="language-klipse-eval-js">
 up(1, 0);
    </code></pre>

    <p>One can even convert an <code>up</code> vector into a JS array, but that is ugly and not used further.</p>

    <pre><code class="language-klipse-eval-js">
cljs.core.clj__GT_js(up(1, 0)).map(sin);
    </code></pre>

    <p>Sure, one can call functions inside of other functions,</p>

    <pre><code class="language-klipse-eval-js">
cos(sin(0));
    </code></pre>

    <p>
        and <code>up</code> is no exception.
    </p>

    <pre><code class="language-klipse-eval-js">
up(cos(0), sin(0));
    </code></pre>

    <p>In JS arrays, not only can one combine numbers, but also functions.</p>

    <pre><code class="language-klipse-eval-js">
[cos, sin];
    </code></pre>

    <p>Also <code>up</code> vectors can contain funtions in the same manner.</p>
    <pre><code class="language-klipse-eval-js">
up(cos, sin);
    </code></pre>

    <p>Now the cool thing is that if an <code>up</code> vector only contains functions, one can call the vector. In this way, a vector behaves itself like a function.</p>

    <pre><code class="language-klipse-eval-js">
up(cos, sin).call(null,0);
    </code></pre>

    <h1>Composition</h1>

    <p>We had functions within functions before</p>

    <pre><code class="language-klipse-eval-js">
cos(sin(0));
    </code></pre>

    <p>The same result is achieved with function composition.</p>

    <pre><code class="language-klipse-eval-js">
var compose = sicmutils.env.compose;
    </code></pre>

    <pre><code class="language-klipse-eval-js">
compose(cos, sin).call(null, 0);
    </code></pre>

    <p>And function composition is indeed necessary when working with vectors.<p>
        <pre><code class="language-klipse-eval-js">
        up(cos, compose(cos, sin)).call(null,0);
        </code></pre>

    <h1>Scheme syntax</h1>

As a follow up to the expositions in blog post <a href="https://kloimhardt.github.io/blog/software/2023/02/22/sicmutils-as-js-3.html">Sicmutils as JavaScript library (3)</a>, we include a simple Scheme syntax to JS transpiler.
    </p>


    <pre><code class="language-klipse-eval-js">
var insertCommas = (txt) =>
txt.replace(/(\w+)/g,'"$1",')
.replace(/\,\s+\]/g," ]");

var makeBrackets = (txt) =>
txt.trim()
.replace(/\(/g,"[ ")
.replace(/\)/g," ],")
.replace(/,$/,"");

var textToJson = (txt) =>
insertCommas(makeBrackets(txt));
    </code></pre>

    <p>
All we have done up to now, is converting the Scheme syntax into a nested JavaScript array (the so called AST).
    </p>

    <pre><code class="language-klipse-eval-js">
(up (cos 0) (sin 0))
    </code></pre>

    <p>The magic is just in this 7 lines of code</p>

    <pre><code class="language-klipse-eval-js">
var jsonToJs = (j) =>
j.constructor == Array
? jsonToJs(j[0]) + ".call(null,"  +  j.slice(1).map(jsonToJs) + ")"
: j;

var expressionToJs = (expr) =>
jsonToJs(JSON.parse(textToJson(expr)));
    </code></pre>

    <p>Scheme syntax transpiled to Javascript</p>

    <pre><code class="language-klipse-eval-js">
;((up cos sin) 0)
    </code></pre>

    <p>Scheme syntax executed</p>

    <pre><code class="language-klipse-eval-js">
((up cos sin) 0) 
    </code></pre>

    <pre><code class="language-klipse-eval-js">
((up cos (compose cos sin)) 0) 
    </code></pre>

    <h1>Eval patch</h1>

    <p>For all this we had to patch the JavaScript <code>eval</code> function: 1. the code is transpiled and executed whenever the text starts with a <code>(</code> and ends with a <code>blank</code> 2. the transpiled code is shown when the text starts with <code>;(</code> 3. the text is executed as JS when it starts with some letter and ends with a <code>;</code></p>

    <pre>&lt;script&gt;
     var oldEval = window.eval;
     var newEval = (txt) =>
        txt.substr(0, 2) === ";("
        ? "Transpiled JS: " + expressionToJs(txt.substr(1))
        : txt[0] === "(" && txt[txt.length - 1] != " "
        ? "Add blank to AST: " + textToJson(txt)
        : txt[0] === "("
        ? oldEval(expressionToJs(txt))
        : txt[txt.length - 1] != ";"
        ? "Add ; to JS: " + txt
        : oldEval(txt);
     window.eval = newEval;
&lt;/script&gt;</pre>

    <script>
     var oldEval = window.eval;
     var newEval = (txt) =>
         txt.substr(0, 2) === ";("
         ? "Transpiled JS: " + expressionToJs(txt.substr(1))
         : txt[0] === "(" && txt[txt.length - 1] != " "
         ? "Add blank to AST: " + textToJson(txt)
         : txt[0] === "("
         ? oldEval(expressionToJs(txt))
         : txt[txt.length - 1] != ";"
         ? "Add ; to JS: " + txt
         : oldEval(txt);
     window.eval = newEval;
    </script>

<script src="https://storage.googleapis.com/app.klipse.tech/plugin_prod/js/klipse_plugin.min.js"></script>
</body>
</html>
